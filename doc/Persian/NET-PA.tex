\documentclass{article}
    \usepackage{amsmath}
    \usepackage{graphicx}
    \usepackage{HandoutTemplate}
    
    \DefaultMathsDigits
    
    \settextfont[Scale=1.1]{B Nazanin}
    %\settextfont[Scale=1.1]{B Nazanin.ttf}
    \setlatintextfont{Times New Roman}
    \setdigitfont{Times New Roman}
    %\setlatindigitfont{Times New Roman}
    
    
    \DeclareMathOperator{\var}{Var}
    
    \begin{document}
    \handout
    {\lr{CE-40695}}
    {۱}
    {آذر ۱۳۹7}
    {پیاده سازی یک شبکه     \lr{P2P}}
    
    \vspace{0.3cm}
    \section{چکیده}
هدف این فاز از پروژه پیاده سازی یک شبکه   \lr{peer to peer} است که در فاز بعدی قرار است یک \lr{block chain application}  روی آن اجرا شود. در این شبکه:
    \begin{itemize}
\item	یک \lr{root}  در نقش \lr{DNS Server}  وجود دارد.
\item	 تعدادی پیام جهت ارتباط  \lr{node} ها با یکدیگر و تشکیل یک گراف همبند بدون دور از آن ها (درخت) رد و بدل میشود. 
\item	ارتباط کاربر با شبکه از طریق یک واسط کاربری انجام میگیرد.
    \end{itemize}
جهت تست این شبکه، باید قابلیت اجرا شدن هم در نقش \lr{root (DNS server)} و هم در نقش \lr{client} را داشته باشید و در نقش  و نحوه رد و بدل شدن پیامها و عملیات مختلف انجام شده در شبکه را مشاهده نمایید.\\
    \section{مقدمه}  
  \section{پروتکل پروژه}
	\subsection{نقش کلاینت ها}
اولین قدم رجیستر شدن هر کلاینت در شبکه است. برای این کار کلاینت با فرستادن یک پیام رجیستر به \lr{root}‌, خودش را رجیستر میکند. برای این کار کلاینت با فرستادن بک پیام رجیستر به روت خودش را در شبکه رجیستر میکند.\\
در ادامه هر کلاینت باید آدرس اولین همسایه خود را از \lr{DNS}‌ بگیرد. برای این کار کلاینت با فرستادن یک پیام در قالب \lr{advertise}‌ به روت شبکه درخواست بک آدرس میکند که در جواب \lr{DNS}‌ هم یک آدرس برمیگرداند. زمانی که از یک کلاینت که قبلا \lr{advertise}‌ شده پیام \lr{advertise}‌ می آید, روت در جواب به آن, آدرس هیچکدام از همسایه از همسایه های \lr{client}‌ را نمی فرستد و به جای آن آدرس جدید میفرستد.\\
کلاینت بعد از پیدا کردن اولین همسابه خود با فرستادن یک \lr{join packet}‌, به اطلاع آن میدهد که درخواست متصل شدن دارد.\\
در این شبکه همه موظف هستند که پیام های دریافتی را از طریق کانکشن ها به همه ارسال کنند.\\
بعد از متصل شدن به اولین همسایه, کلاینت میتواند پیام های خود را به صورت \lr{broadcast}‌ به شبکه ارسال کند.\\
بعد از اتصال به همسایه هر \lr{node}‌ موظف است هر 4 ثانیه یک بار از طریق همسایه خود به روت یک پیام \lr{reunion hello}‌ ارسال کند.\\
روت انتظار دارد این پیام هر 36 ثانیه یک بار از هر کلاینت به او برسد در غیر این صورت فرض میکند این کلاینت در شبکه وجود ندارد و دیگر آن را \lr{advertise}‌ نمیکند.\\
هر کلاینتی که پیام \lr{reunion hello}‌ به دستش میرسد باید آدرش خود را به ته پیام بچسباند, \lr{field number of entities}‌ را آپدیت کند و به پدرش ارسال کند. و اگر هم \lr{reunion hello back}‌ رسید, آدرس خودش را از پیام بر میدارد, \lr{field number of entities}‌ را آپدیت میکند و به نفر بعدی میدهد.\\
لازم به ذکر است که در این شبکه عمق درخت حداکثر 8 فرض شده است.\\
	\subsection{نقش روت}
اولین وظیفه روت رچیستر کردن \lr{client}‌ ها در شبکه با جواب دادن به \lr{register request}‌ آن ها است.\\
در گام بعدی روت وظیه دارد جواب \lr{advertise request}‌ کلاینت ها را با دادن آدرس یک \lr{peer}‌, با فرض اینکه در گراف اتصالات تشکیل شده هیچ \lr{peer}‌ ای وجود ندارد که بیشتر از 2 فرزند داشته باشد, به آن ها دهد.\\
آخرین وطیفه روت انتظار برای رسیدن یک \lr{reuninon hello}‌ به ازای هر \lr{client}‌ در مدت زمان 36 ثانیه و برگرداندن یک پیام \lr{reuninon hello back}‌ به آنهاست. اگر \lr{reunion hello}‌ در این مدت نرسید, روت دیگر آن \lr{node}‌ و فرزندانش را \lr{advertise}‌ نمیکند.

    \section{توضیحات پیاده سازی}
در ادامه به معرفی وظایف اشیاء ساخته شده از هر کلاس و تابعهای موجود در آنها و همچنین نحوه گرفتن ورودی در آنها میپردازیم.
	\subsection{\lr{Peer}}
 \lr{Stream}  موجود در \lr{constructor}‌ این کلاس، یک \lr{server\_ip} و یک \lr{server\_port} را وردوی میگیرد که \lr{ip} و \lr{port} همان سرور خودمان هستند. مقدار \lr{parent} چنانچه ما \lr{root} باشیم \lr{none} است و در غیر این صورت هنگامی که درخواست \lr{join} را ارسال میکنیم مشخص میشود. \lr{Packets} هم همان بسته هایی است که دریافت کرده و باید به آن ها رسیدگی کنیم. \lr{Neighbours} همان بچه های ما هستند. هر \lr{peer} یک \lr{UserInterface} و یک \lr{PacketFactory} هم دارد. اگر \lr{root} باشیم، به \lr{network\_nodes} احتیاج داریم که تمامی \lr{node} های این شبکه را در بر میگیرد؛ همچنین به \lr{registered\_nodes} جهت ثبت \lr{node} هایی که به واسطه ما در شبکه \lr{register} کرده اند احتیاج داریم. اگر هم ‌\lr{root}نباشیم، \lr{root} را مشخص کرده و به \lr{stream} هم \lr{root} را اضافه میکنیم (یعنی یک \lr{register\_node} در \lr{root} اضافه میکنیم.).
پیاده سازی تابع \lr{start\_user\_interface} به این صورت است که تنها \lr{user\_interface} را اجرا میکند. پس از آن، برنامه منتظر دستور کاربر میماند. دستورات کاربر به فرمت زیر هستند:
    \begin{itemize}
\item	\lr{ new\_register\_packet :1}
\item	\lr{ new\_advertise\_packet :2}
\item	 \lr{ send\_broadcast\_packet :3}
    \end{itemize}
که بر اساس عدد وارد شده توسط کاربر، عملیات نظیر شده به آن در تابع \lr{handle\_user\_interface\_buffer} اجرا میشود.
در تابع ، \lr{run}\lr{read\_in\_buf} مربوط به \lr{stream} را میخوانیم، بسته ها را میسازیم و به آنها رسیدگی میکنیم و در همان لحظه این بافر را پاک میکنیم تا به یک پیام دو بار رسیدگی نکنیم. پس از آن به  \lr{user interface}رسیدگی میکنیم و هر بسته ای که احتیاج داریم بفرستیم را میفرستیم و برای یک دوره زمانی، استراحت \lr{(sleep!)} میکنیم. 
برای فرستادن یک \lr{broadcast packet}، از تابع \lr{send\_broadcast\_packet} استفاده میکنیم.
تابعی به اسم \lr{handle\_packet} وجود دارد که برای بررسی بستهها مورد استفاده قرار میگیرد. به عنوان نمونه، طول هر بسته در آن چک می¬شود.
در تابع \lr{check\_registered} یک آدرس ورودی میگیریم و چک میکنیم که آن \lr{node} در بین \lr{registered\_node} ها وجود دارد یا خیر.
در تابع \lr{handle\_advertise\_packet} اول چک میکنیم که نوع بسته دریافت شده چیست؛ اگر از نوع \lr{request} باشد، باید حتما \lr{root} باشیم تا بتوانیم آن را بررسی کنیم (در غیر این صورت، آن را دور می ریزیم.). در این صورت، اگر \lr{register} شده بود، از یکی از همسایه های آن را پیدا میکنیم تا به آن \lr{advertise request} بفرستیم.  


	\subsection{\lr{Stream}}
	در تابع     \lr{constructor} این کلاس ابتدا با متد \lr{is\_valid} فرمت های \lr{IP} و \lr{Port} را چک میکنیم تا مطمئن شویم به صورت همان فرمت مورد نظر هستند. \lr{server\_in\_buf} همان بافری هست که روی سرور نوشته میشود و هر چند وقت یک بار بایستی چک شود. \lr{Callback Function (cb)} نیز پیام های جدید را به ته \lr{server\_in\_buf} میچسباند \lr{(append)} و در نهایت \lr{Ack} برمیگرداند. این \lr{Ack} باعث میشود هر جا که سوکتی وسط کار قطع شود بفهمد قطع شده است. سپس \lr{tcpserver} را مسازیم, در یک \lr{thread} قرار میدهیم و آن را اجرا میکنیم. \lr{self.nodes} تمام نود هایی هستند که درون ما هستند.\\
\lr{get\_server\_address} آدرس سرور را با آن فرمتی که میخواهیم به ما میدهد.
\\ 
\lr{clear\_in\_buf} بافر سرور را پاک میکند.
\\
\lr{add\_node} نود اضافه میکند.
\\
\lr{remove\_node} نود مشخص شده را از آرایه پاک میکند و سپس  متد \lr{close} نود را اجاره میکند.
\\
\lr{get\_node\_by\_server} آی پی و پورت سرور  یک نود را میگیرد و نود را برمیگرداند. سپس با \lr{parse} کردن آن را به فرمت مد نظر تبدیل میکند.
\\
\lr{add\_message\_to\_out\_buffer} با گرفتن یک آدرس و پیام نود را پیدا میکند و در \lr{out\_buffer} مینویسد.
\\
\lr{read\_in\_buf} وظیفه دارد \lr{read\_in\_buf} را برگرداند.
\\
\lr{send\_message\_to\_node} بافرهای توی نود را با استفاده از کال کردن تابع\lr{send\_message}  خودش ارسال میکند.
\\
\lr{send\_out\_buf\_messages} پیام تمامی نود ها را ارسال میکند. 
\\
	\subsection{\lr{Node}}
در \lr{constructor} این آبجکت ابتدا \lr{IP/Port} سرور با \lr{parse} شدن به فرمت مورد نظر در می آیند.\lr{out\_buff} بافری هست که قراره روی کلاینتش بنویسیم برود. با \lr{is\_register\_connection} چک میکنیم رجیستر هست یا خیر. در آخر یک \lr{try/catch} برای سوکت کلاینت قرار میدهیم تا اگر نودی در آن وسط \lr{deatach} شد \lr{exception} بخورد و از \lr{out\_buffer} پاک مشود.
\\
\lr{send\_message} به ازای هر بافر یک \lr{self.client.send} میکند و اگر \lr{Ack} برگشت یعنی پیام ارسال شده است.
\\
    \vfill
    \vspace{1cm}
    $\hfill$ موفق باشید
    \end{document}