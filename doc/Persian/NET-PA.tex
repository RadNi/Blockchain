\documentclass{article}
    \usepackage{amsmath}
    \usepackage{graphicx}
    \usepackage{HandoutTemplate}
    
    \DefaultMathsDigits
    
    \settextfont[Scale=1.1]{B Nazanin}
    %\settextfont[Scale=1.1]{B Nazanin.ttf}
    \setlatintextfont{Times New Roman}
    \setdigitfont{Times New Roman}
    %\setlatindigitfont{Times New Roman}
    
    
    \DeclareMathOperator{\var}{Var}
    
    \begin{document}
    \handout
    {\lr{CE-40695}}
    {۱}
    {آذر ۱۳۹7}
    {پیاده سازی یک شبکه     \lr{P2P}}
    
    \vspace{0.3cm}
    \section{مقدمه}
هدف این فاز از پروژه پیاده سازی یک شبکه   \lr{peer to peer} است که در فاز بعدی قرار است یک \lr{block chain application}  روی آن اجرا شود. در این شبکه:
    \begin{itemize}
\item	یک \lr{root}  در نقش \lr{DNS Server}  وجود دارد.
\item	 تعدادی پیام جهت ارتباط  \lr{node} ها با یکدیگر و تشکیل یک گراف همبند بدون دور از آن ها (درخت) رد و بدل میشود. 
\item	ارتباط کاربر با شبکه از طریق یک واسط کاربری انجام میگیرد.
    \end{itemize}
جهت تست این شبکه، باید یک دفعه آن را به عنوان  \lr{server}  و \lr{n} دفعه به عنوان \lr{client} آن را اجرا کنید و نحوه رد و بدل شدن پیامها و عملیات مختلف انجام شده در شبکه را مشاهده نمایید.\\
ساختار کلی کلاسهای این کد به صورت زیر است:


    \section{اشیا}
در ادامه به معرفی وظایف اشیاء ساخته شده از هر کلاس و تابعهای موجود در آنها و همچنین نحوه گرفتن ورودی در آنها میپردازیم.
	\subsection{\lr{Peer}}
 \lr{Stream}  موجود در \lr{constructor}‌ این کلاس، یک \lr{server\_ip} و یک \lr{server\_port} را وردوی میگیرد که \lr{ip} و \lr{port} همان سرور خودمان هستند. مقدار \lr{parent} چنانچه ما \lr{root} باشیم \lr{none} است و در غیر این صورت هنگامی که درخواست \lr{join} را ارسال میکنیم مشخص میشود. \lr{Packets} هم همان بسته هایی است که دریافت کرده و باید به آن ها رسیدگی کنیم. \lr{Neighbours} همان بچه های ما هستند. هر \lr{peer} یک \lr{UserInterface} و یک \lr{PacketFactory} هم دارد. اگر \lr{root} باشیم، به \lr{network\_nodes} احتیاج داریم که تمامی \lr{node} های این شبکه را در بر میگیرد؛ همچنین به \lr{registered\_nodes} جهت ثبت \lr{node} هایی که به واسطه ما در شبکه \lr{register} کرده اند احتیاج داریم. اگر هم ‌\lr{root}نباشیم، \lr{root} را مشخص کرده و به \lr{stream} هم \lr{root} را اضافه میکنیم (یعنی یک \lr{register\_node} در \lr{root} اضافه میکنیم.).
پیاده سازی تابع \lr{start\_user\_interface} به این صورت است که تنها \lr{user\_interface} را اجرا میکند. پس از آن، برنامه منتظر دستور کاربر میماند. دستورات کاربر به فرمت زیر هستند:
    \begin{itemize}
\item	\lr{ new\_register\_packet :1}
\item	\lr{ new\_advertise\_packet :2}
\item	 \lr{ send\_broadcast\_packet :3}
    \end{itemize}
که بر اساس عدد وارد شده توسط کاربر، عملیات نظیر شده به آن در تابع \lr{handle\_user\_interface\_buffer} اجرا میشود.
در تابع ، \lr{run}\lr{read\_in\_buf} مربوط به \lr{stream} را میخوانیم، بسته ها را میسازیم و به آنها رسیدگی میکنیم و در همان لحظه این بافر را پاک میکنیم تا به یک پیام دو بار رسیدگی نکنیم. پس از آن به  \lr{user interface}رسیدگی میکنیم و هر بسته ای که احتیاج داریم بفرستیم را میفرستیم و برای یک دوره زمانی، استراحت \lr{(sleep!)} میکنیم. 
برای فرستادن یک \lr{broadcast packet}، از تابع \lr{send\_broadcast\_packet} استفاده میکنیم.
تابعی به اسم \lr{handle\_packet} وجود دارد که برای بررسی بستهها مورد استفاده قرار میگیرد. به عنوان نمونه، طول هر بسته در آن چک می¬شود.
در تابع \lr{check\_registered} یک آدرس ورودی میگیریم و چک میکنیم که آن \lr{node} در بین \lr{registered\_node} ها وجود دارد یا خیر.
در تابع \lr{handle\_advertise\_packet} اول چک میکنیم که نوع بسته دریافت شده چیست؛ اگر از نوع \lr{request} باشد، باید حتما \lr{root} باشیم تا بتوانیم آن را بررسی کنیم (در غیر این صورت، آن را دور می ریزیم.). در این صورت، اگر \lr{register} شده بود، از یکی از همسایه های آن را پیدا میکنیم تا به آن \lr{advertise request} بفرستیم.  


	\subsection{\lr{Stream}}
	در تابع     \lr{constructor} این کلاس ابتدا با متد \lr{is\_valid} فرمت های \lr{IP} و \lr{Port} را چک میکنیم تا مطمئن شویم به صورت همان فرمت مورد نظر هستند. \lr{server\_in\_buf} همان بافری هست که روی سرور نوشته میشود و هر چند وقت یک بار بایستی چک شود. \lr{Callback Function (cb)} نیز پیام های جدید را به ته \lr{server\_in\_buf} میچسباند \lr{(append)} و در نهایت \lr{Ack} برمیگرداند. این \lr{Ack} باعث میشود هر جا که سوکتی وسط کار قطع شود بفهمد قطع شده است. سپس \lr{tcpserver} را مسازیم, در یک \lr{thread} قرار میدهیم و آن را اجرا میکنیم. \lr{self.nodes} تمام نود هایی هستند که درون ما هستند.\\
\lr{get\_server\_address} آدرس سرور را با آن فرمتی که میخواهیم به ما میدهد.
\\ 
\lr{clear\_in\_buf} بافر سرور را پاک میکند.
\\
\lr{add\_node} نود اضافه میکند.
\\
\lr{remove\_node} نود مشخص شده را از آرایه پاک میکند و سپس  متد \lr{close} نود را اجاره میکند.
\\
\lr{get\_node\_by\_server} آی پی و پورت سرور  یک نود را میگیرد و نود را برمیگرداند. سپس با \lr{parse} کردن آن را به فرمت مد نظر تبدیل میکند.
\\
\lr{add\_message\_to\_out\_buffer} با گرفتن یک آدرس و پیام نود را پیدا میکند و در \lr{out\_buffer} مینویسد.
\\
\lr{read\_in\_buf} وظیفه دارد \lr{read\_in\_buf} را برگرداند.
\\
\lr{send\_message\_to\_node} بافرهای توی نود را با استفاده از کال کردن تابع\lr{send\_message}  خودش ارسال میکند.
\\
\lr{send\_out\_buf\_messages} پیام تمامی نود ها را ارسال میکند. 
\\
	\subsection{\lr{Node}}
در \lr{constructor} این آبجکت ابتدا \lr{IP/Port} سرور با \lr{parse} شدن به فرمت مورد نظر در می آیند.\lr{out\_buff} بافری هست که قراره روی کلاینتش بنویسیم برود. با \lr{is\_register\_connection} چک میکنیم رجیستر هست یا خیر. در آخر یک \lr{try/catch} برای سوکت کلاینت قرار میدهیم تا اگر نودی در آن وسط \lr{deatach} شد \lr{exception} بخورد و از \lr{out\_buffer} پاک مشود.
\\
\lr{send\_message} به ازای هر بافر یک \lr{self.client.send} میکند و اگر \lr{Ack} برگشت یعنی پیام ارسال شده است.
\\
    \vfill
    \vspace{1cm}
    $\hfill$ موفق باشید
    \end{document}