\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{array}
\usepackage{underscore}
\usepackage{tabu}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{tikz-uml}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\title{A Simple Peer To Peer Network Implementation}
\author{Hoora Abootalebi\\Nariman Aryan\\Amin Isaai\\Amirhossein Khajepour\\Mahdis Tajdari\\Ali Zeynali}
\date{ November 2018}

\begin{document}


\large
\maketitle
\clearpage
\tableofcontents
\clearpage
\section{Introdeuction}
\paragraph{}This project aims to implement a peer to peer network. In the first step we design UML model and then we are going to explain each objects' attributes and methods. 
\section{UML model}
\paragraph{}We design the UML model in order to make the project more understandable, clearer and professional.
\clearpage
\begin{tikzpicture}
<<<<<<< HEAD
%---------Stream--------------------------
\umlclass[x=3, y=5, anchor=north]{Stream}{-_server_in_buf : dictionary \\+messages_dic :dict\\+nodes : dictionary\\+ip\\+port}{+cb(ip, queue, data)\\+get\_server\_address(self)\\ +add\_node(self, server_address)\\+is\_valid(self, ip, port)\\+remove\_node(self, cl)\\+get\_node\_by\_server(self, ip, port)\\+add\_message\_to\_out\_buff(self, address, message)\\+remove\_node\_by\_server\_info(self, ip, port)\\+read\_in\_buf(self)\\+send\_messages\_to\_node(self, node)\\+send\_out\_buf\_messages(self)}

%------Packet Factory----------
\umlclass[x=-3, y=-2, anchor=north]{Packet Factory}{}{+parse\_buffer(self, buffer)\\+new\_reunion\_packet(self, type,  nodes_array)\\+new\_advertise\_packet(self, type, source_server_address, neighbor=None)\\+new_join_packet(self, source_server_address)\\+new\_register\_packet(self, type, source_server_address, address=(None, None))\\+new_message_packet(self, message, source_server_address)}

%------Peer--------------------------
\umlclass[x=0, y=-6, anchor=north]{Peer}{-\_is\_root\\+stream\\+parent\\+packets\\+neighbours\\-_user_interface\\-_user_interface_buffer\\-_broadcast_packets\\+packet_factory\\+network_nodes}{+start_user_interface(self)\\+handle_user_interface_buffer(self)\\+run(self)\\+handle_packet(self, packet)\- __handle_advertise_packet(self, packet)\\- __handle_register_packet(self, packet)\\-  __handle_message_packet(self, packet)\\-  __handle_reunion_packet(self, packet)\\-__handle_join_packet(self, packet)\\- __get_neighbour(self, sender)}
%-----------------------------------------------------------
\umlassoc[arm2=-1.2cm]{Peer}{Packet Factory}
\umlassoc[arm2=-1.2cm]{Peer}{Stream}
\end{tikzpicture}
\clearpage
\begin{tikzpicture}
%------------------------------------------------------------------------
\umlclass[x=-4, y=-8, anchor=north]{Packet}{- _buf: \\- _header:\\-_version:\\-_type: String\\-_length: \\-_source_server_ip\\-_source_server_port\\-_body: String\\}{+ get\_header()\\+ get\_version()\\+ get\_type()\\+ get\_length()\\+ get\_body()\\+ get_buf(self)\\+ get_source_server_ip(self)\\+get_source_server_port(self)\\+get_source_server_address(self)}
\umlclass[x=+1.5, y=-11, anchor=north]{Reunion}{}{get\_destination()}
\umlclass[x=0, y=-14 ,anchor=north]{Advertise}{ip: String\\port: String}{}
\umlclass[x=-3, y=-14, anchor=north]{Message}{plain\_text : String}{}
\umlclass[x=-7, y=-14 ,anchor=north]{Register Request}{ip: String\\port: String}{}
=======
\umlclass[x=0, y=1, anchor=north]{Stream}{server : dictionary \\nClient : dictionary\\ clientMsg :dict \\serverBuffer : string}{add\underline{\hspace{.05in}}client(ip,port)\\remove\underline{\hspace{.05in}}client(ip,port)\\read\underline{\hspace{.05in}}inBuff()\\send\underline{\hspace{.05in}}message()} 
\umlclass[x=-6, y=1, anchor=north]{Packet Factory}{}{parse\underline{\hspace{.05in}}buf()\\new\underline{\hspace{.05in}}reunion()\\new\underline{\hspace{.05in}}adv()\\new\underline{\hspace{.05in}}reg()} 
\umlclass[x=-3, y=-4, anchor=north]{Peer}{}{user\underline{\hspace{.05in}}interface()\\run()\\packetFactory()\\handle\underline{\hspace{.05in}}packets()} 
\umlassoc[arm2=-1.2cm]{Peer}{Packet Factory}
\umlassoc[arm2=-1.2cm]{Peer}{Stream}
\umlclass[x=-4, y=-8, anchor=north]{Packet}{type: String\\node:\\header: String\\body: String\\}{}
\umlclass[x=+1.5, y=-11, anchor=north]{Reunion}{}{get\underline{\hspace{.05in}}destination()}  
\umlclass[x=0, y=-14 ,anchor=north]{Advertise}{ip: String\\port: String}{}  
\umlclass[x=-3, y=-14, anchor=north]{Message}{plain\underline{\hspace{.05in}}text : String}{}
\umlclass[x=-7, y=-14 ,anchor=north]{Register Request}{ip: String\\port: String}{}  
>>>>>>> 313a51976ec9f7591fef2d8cbe1bf8efbc743e60
\umlclass[x=-9.5, y=-11, anchor=north]{Register Response}{ack : String}{}
\umlinherit[arm2=-1.2cm]{Reunion}{Packet} 
\umlinherit[arm2=-1.2cm]{Advertise}{Packet}
\umlinherit[arm2=-1.2cm]{Message}{Packet}
\umlinherit[arm2=-1.2cm]{Register Request}{Packet}
\umlinherit[arm2=-1.2cm]{Register Response}{Packet}
\end{tikzpicture}
\section{Objects}
\paragraph{}Now it's time to explain every obejct's duty.
\subsection{Stream}This objects has one server and n clients. Servers are always open for reading and clients will be open whenever we want to write on a socket. \\
There is a clientMsg dictionary in this object to handle messages. This means that there is an array assigned to a specific client for all clients. If we need to add a new client to this object, we use add\underline{\hspace{.05in}}client() method. Consequently, an array will be assigned to this new client in clientMsg.\\
There is also a remove\underline{\hspace{.05in}}client() method for the times when we want to remove a client from this object. This method is mostly used  when reunion fails.\\
The read\underline{\hspace{.05in}}inBuf returns the buffer of the server.\\
The send\underline{\hspace{.05in}}msg() method is used when peer wants to send a message to a specific client.\\
Byte\underline{\hspace{.05in}}ack() is used to reply to the receives messages. We must reply all of the receives messages by sending Ack (which is a string).\\
\begin{lstlisting}
#stream()
    def __init__(self, ip, port):
        """
        :param ip: 15 characters
        :param port: 5 characters
        """
        if not self.is_valid(ip, port):
            raise Exception("Invalid format of ip or port for TCPServer.")
            #   TODO    Error handling

        self.messages_dic = {}
        self._server_in_buf = []
        # self.parent = None
        #   TODO    Parent should be in Peer object not here

        def cb(ip, queue, data):
            queue.put(bytes('ACK', 'utf8'))
            print("In callback: ", data)
            # self.messages_dic.update({ip: self.messages_dic.get(ip).append(data)})
            self._server_in_buf.append(data)

        print("Binding server: ", ip, ": ", port)
        self._server = TCPServer(ip, port, cb)
        self._server.run()
        self.nodes = []
        self.ip = ip
        self.port = port

    def get_server_address(self):
        return Node.parse_ip(self._server.ip), Node.parse_port(self._server.port)

    def add_node(self, server_address):
        self.nodes.append(Node(server_address))

    def is_valid(self, ip, port):
        if len(str(ip)) != 15 or len(str(port)) > 5:
            return False
        return True

    def remove_node(self, cl):
        self.nodes.remove(cl)
        cl.close()

    def get_node_by_server(self, ip, port):
        """
        :param ip:
        :param port:
        :return:
        :rtype: Node
        """
        port = Node.parse_port(port)
        ip = Node.parse_ip(ip)
        for nd in self.nodes:
            if nd.get_server_address()[0] == ip and nd.get_server_address()[1] == port:
                return nd

    def add_message_to_out_buff(self, address, message):
        print("add message to out buff: ", address, " ", message)
        n = self.get_node_by_server(address[0], address[1])
        # if n is None:
        #     n = self.get_node_by_client(address[0], address[1])
        if n is None:
            raise Exception("Unexpected address to add message to out buffer.")

        n.add_message_to_out_buff(message)

    def remove_node_by_server_info(self, ip, port):
        rem_client = None
        for nd in self.nodes:
            if nd.get_server_address[0] == ip and nd.get_server_address[1] == port:
                rem_client = nd
                break
        if rem_client is not None:
            self.remove_node(rem_client)

    def read_in_buf(self):
        return self._server_in_buf

    def send_messages_to_node(self, node):
        """
        Send buffered messages to the 'node'
        :param node:
        :type node Node
        :return:
        """

        response = node.send_message()

    def send_out_buf_messages(self):
        """
        In this function we will send hole out buffers to their own clients.
        :return:
        """

        for n in self.nodes:
            self.send_messages_to_node(n)    def __init__(self, ip, port):
        """
        :param ip: 15 characters
        :param port: 5 characters
        """
        if not self.is_valid(ip, port):
            raise Exception("Invalid format of ip or port for TCPServer.")
            #   TODO    Error handling

        self.messages_dic = {}
        self._server_in_buf = []
        # self.parent = None
        #   TODO    Parent should be in Peer object not here

        def cb(ip, queue, data):
            queue.put(bytes('ACK', 'utf8'))
            print("In callback: ", data)
            # self.messages_dic.update({ip: self.messages_dic.get(ip).append(data)})
            self._server_in_buf.append(data)

        print("Binding server: ", ip, ": ", port)
        self._server = TCPServer(ip, port, cb)
        self._server.run()
        self.nodes = []
        self.ip = ip
        self.port = port

    def get_server_address(self):
        return Node.parse_ip(self._server.ip), Node.parse_port(self._server.port)

    def add_node(self, server_address):
        self.nodes.append(Node(server_address))

    def is_valid(self, ip, port):
        if len(str(ip)) != 15 or len(str(port)) > 5:
            return False
        return True

    def remove_node(self, cl):
        self.nodes.remove(cl)
        cl.close()

    def get_node_by_server(self, ip, port):
        """
        :param ip:
        :param port:
        :return:
        :rtype: Node
        """
        port = Node.parse_port(port)
        ip = Node.parse_ip(ip)
        for nd in self.nodes:
            if nd.get_server_address()[0] == ip and nd.get_server_address()[1] == port:
                return nd

    def add_message_to_out_buff(self, address, message):
        print("add message to out buff: ", address, " ", message)
        n = self.get_node_by_server(address[0], address[1])
        # if n is None:
        #     n = self.get_node_by_client(address[0], address[1])
        if n is None:
            raise Exception("Unexpected address to add message to out buffer.")

        n.add_message_to_out_buff(message)

    def remove_node_by_server_info(self, ip, port):
        rem_client = None
        for nd in self.nodes:
            if nd.get_server_address[0] == ip and nd.get_server_address[1] == port:
                rem_client = nd
                break
        if rem_client is not None:
            self.remove_node(rem_client)

    def read_in_buf(self):
        return self._server_in_buf

    def send_messages_to_node(self, node):
        """
        Send buffered messages to the 'node'
        :param node:
        :type node Node
        :return:
        """

        response = node.send_message()

    def send_out_buf_messages(self):
        """
        In this function we will send hole out buffers to their own clients.
        :return:
        """

        for n in self.nodes:
            self.send_messages_to_node(n)
\end{lstlisting}
\paragraph{}We also need to add a dictionary to specify every client's message(s)
\subsection{Peer}This object is the main object that we are working with. It must have a Stream object which provides the connection to the socket; This means that reading and writing are done using the Stream object. Peer must also have a userInterface object in order to facilitate commanding by users.(.e.g. for connecting or sending message to a specific node)\\
The run method handles all of the events included in stream in an infinite loop and it also handles the received messages; This means that it does a certain action based on the type of the received packet.

\begin{lstlisting}
#Peer()
stream()
user_interface()   #Which the user or client sees and works with. 
run() 				#This method runs every time to see 
				     #whether there is new messages or not.
packetFactory()
handle_packets()
\end{lstlisting}
\subsection{Packet Factory}
\paragraph{packetFactory()}The main functionality of this object is to create different types of packet and return them. To be more specific, we read data from buffer and we pass it through pars\underline{\hspace{.05in}}buff() method in order to get a packet.
\begin{lstlisting}
#packetFactory
 def parse_buffer(self, buffer):

        """
        :param buffer: The buffer that should be parse to a validate packet format
        :return new packet
        :rtype Packet
        """

        return Packet(buf=buffer)

    def new_reunion_packet(self, type,  nodes_array):
        """
        :param destination: (ip, port) of destination want to send reunion packet.
        :param nodes_array: [(ip0, port0), (ip1, port1), ...] It is the path to the 'destination'.
        :return New reunion packet.
        :rtype Packet
        """
        version = '1'
        packet_type = '05'
        if type == 'REQ':
            body = 'REQ'
        elif type == 'RES':
            body = 'RES'
        else:
            return None
        number_of_entity = str(len(nodes_array))
        if len(number_of_entity) < 2:
            number_of_entity = '0' + number_of_entity
        body = body + number_of_entity
        for (ip, port) in nodes_array:
            body = body + ip
            body = body + port
        length = str(len(body))
        while len(length) < 5:
            length = '0' + length
        return Packet(version + packet_type + length + body)

    def new_advertise_packet(self, type, source_server_address, neighbor=None):
        """
        :param type: Type of Advertise packet
        :param source_server_address Server address of the packet sender.
        :param neighbor: The neighbor for advertise response packet; The format is like ('192.168.001.001', '05335').
        :type type: str
        :type source_server_address: tuple
        :type neighbor: tuple
        :return New advertise packet.
        :rtype Packet
        """
        print("Creating advertisement packet")
        version = '1'
        packet_type = '02'

        if type == 'REQ':
            body = 'REQ'
            length = '00003'
            print("Request adv packtet created")
            return Packet(version + packet_type + length + source_server_address[0] + source_server_address[1] + body)

        elif type == 'RES':
            try:
                body = 'RES'
                body += neighbor[0]
                body += neighbor[1]
                length = '00023'
                print("Response adv packtet created")
                return Packet(
                    version + packet_type + length + source_server_address[0] + source_server_address[1] + body)
            except Exception as e:
                print(str(e))
        else:
            raise Exception("Type is incorrect")

    def new_join_packet(self, source_server_address):
        """
        :param source_server_address: Server address of the packet sender.
        :type source_server_address: tuple
        :return New join packet.
        :rtype Packet
        """
        print("Creating join packet")
        version = '1'
        packet_type = '03'
        length = '00004'
        body = 'JOIN'

        return Packet(version + packet_type + length + source_server_address[0] + source_server_address[1] + body)

    def new_register_packet(self, type, source_server_address, address=(None, None)):
        """
        :param type: Type of Register packet
        :param source_server_address: Server address of the packet sender.
        :param address: If type is request we need address; The format is like ('192.168.001.001', '05335').
        :type type: str
        :type source_server_address: tuple
        :type address: tuple
        :return New Register packet.
        :rtype Packet
        """
        print("Creating register packet")
        version = "1"
        packet_type = "01"

        if type == "REQ":
            length = "00023"
            body = "REQ" + '.'.join(str(int(part)).zfill(3) for part in address[0].split('.')) + \
                   str(address[1]).zfill(5)
            print("Request register packet created")
        elif type == "RES":
            length = "00006"
            body = "RES"
            print("Response register packet created")
        else:
            raise Exception("Irregular register type.")

        return Packet(version + packet_type + length + source_server_address[0] + source_server_address[1] + body)

        pass

    def new_message_packet(self, message, source_server_address):
        """
        Packet for sending a broadcast message to hole network.
        :param message: Our message
        :param source_server_address: Server address of the packet sender.
        :type message: str
        :type source_server_address: tuple
        :return: New Message packet.
        :rtype: Packet
        """
        version = '1'
        packet_type = '04'
        body = message
        length = len(message)
        for i in range(length, 5):
            length = '0' + length
        print("Message packet created")
        return Packet(version + packet_type + length + source_server_address[0] + source_server_address[1] + body)
\end{lstlisting}
\subsection{Packet}
<<<<<<< HEAD
\paragraph{}Every packet consists seven differntes parts: \textbf{plain\_text} which is the raw text message in the packet.\\
\begin{lstlisting}
#Packet
def __init__(self, buf):
        self._buf = buf
        self._header = buf[0:28]
        self._version = int(buf[0], 10)
        self._type = int(buf[1:3], 10)
        self._length = int(buf[3:8], 10)
        self._source_server_ip = buf[8:23]
        self._source_server_port = buf[23:28]
        self._body = buf[8:]

    def get_header(self):
        """
        :return: Packet header
        :rtype: str
        """

        return self._header

    def get_version(self):
        """
        :return: Packet Version
        :rtype: int
        """
        return self._version

    def get_type(self):
        """
        :return: Packet type
        :rtype: int
        """
        return self._type

    def get_length(self):
        """
        :return: Packet length
        :rtype: int
        """
        return self._length

    def get_body(self):
        """
        :return: Packet body
        :rtype: str
        """
        return self._body

    def get_buf(self):
        """
        :return Packet buffer
        :return: str
        """
        return self._buf

    def get_source_server_ip(self):
        """
        :return: Server IP address for sender of the packet.
        :rtype: str
        """
        return self._source_server_ip

    def get_source_server_port(self):
        """
        :return: Server Port address for sender of the packet.
        :rtype: str
        """
        return self._source_server_port

    def get_source_server_address(self):
        """
        :return: Server address; The format is like ('192.168.001.001', '05335').
        :rtype: tuple
        """

        return self.get_source_server_ip(), self.get_source_server_port()
\end{lstlisting}
=======
\paragraph{}Every packet consists seven differntes parts: \textbf{plain\underline{\hspace{.05in}}text} which is the raw text message in the packet.\\
>>>>>>> 313a51976ec9f7591fef2d8cbe1bf8efbc743e60
\textbf{Node}: Specifies to which node the packet sent to. \textbf{Sender} specifies who sent the packet \textbf{Validator} which makes the packet valid.\\ \textbf{Header} where the information such as type of the packet and etc. are going to be there.\\ \textbf{Body} body of our packet .
\subsection{Reunion}
\paragraph{reunion(packet)} checks the connection of the nodes to the root. This is one type of packets which each node has to send it to the root every 20 seconds to clarify is still live. \\
A node who want to send reunion packet, after creating the header, inserts it's ip and port in the body and passes it to his father. Then the father should append it's ip and port at the end of the body then passes it to the next father... \\
When the root recieves the reunion packet from one node, the root should reverse the sort of ip and ports in the reunion's body then sets it as the reunion answer's body and pass it to the node which gave the reunion to the root. \\
Each node which receives the reunion answer from it's father, should check if the first ip and port in the body are for himself or not. If yes, it should pop his port and ip from the body and then send it to the next node which it's ip and port are in the top of the body.
This process continue until the destination node receives the reunion answer.
\begin{lstlisting}
#reunion(packet)
 get_destination()
\end{lstlisting}
\subsection{Node}
\begin{lstlisting}
#Node
def send_message(self):
        """
        Final function to send buffer to the clients socket.
        :return:
        """
        print("in sending message: ", self.out_buff)
        for b in self.out_buff:
            print(b)
            response = self.client.send(b)

            if response.decode("UTF-8") != bytes('ACK'):
                print("The ", self.get_server_address()[0], ": ", self.get_server_address()[1],
                      " did not response with b'ACK'.")

    def add_message_to_out_buff(self, message):
        """
        Here we will add new message to the server out_buff, then in 'send_message' will send them.
        :param message: The message we want to add to out_buff
        :return:
        """
        self.out_buff.append(message)

    def close(self):
        """
        Closing client object.
        :return:
        """
        self.client.close()

    def get_server_address(self):
        """
        :return: Server address in a pretty format.
        :rtype: tuple
        """
        return self.server_ip, self.server_port

    @staticmethod
    def parse_ip(ip):
        """
        Automatically change the input IP format like '192.168.001.001'.
        :param ip: Input IP
        :type ip: str
        :return: Formatted IP
        :rtype: str
        """
        return '.'.join(str(int(part)).zfill(3) for part in ip.split('.'))

    @staticmethod
    def parse_port(port):
        """
        Automatically change the input IP format like '05335'.
        :param port: Input IP
        :type port: str
        :return: Formatted IP
        :rtype: str
        """
        return str(int(port)).zfill(5)
\end{lstlisting}
\paragraph{}Every node has two parameters: \textbf{IP} and \textbf{Port}.
\subsection{Resgister Request}
\paragraph{reg\underline{\hspace{.05in}}req()} sends IP/Port of a node to the root to ask if it can register it. 
\subsection{Register Response}
\paragraph{reg\underline{\hspace{.05in}}res()} should just send an from the root $Ack$ to inform a node that it has been registerd in the root if the reg\underline{\hspace{.05in}}req() was successful.
\subsection{Advertise}
\paragraph{adv(packet)}
\subsection{Mesasge}
\paragraph{msg(packet)}
\clearpage





\end{document}
